/*
 *Very Large Integer Library, License - Version 1.0 - May 3rd, 2012
 *
 *Timothee Ewart - University of Geneva,
 *Andreas Hehn - Swiss Federal Institute of technology Zurich.
 *Maxim Milakov â€“ NVIDIA
 *
 *Permission is hereby granted, free of charge, to any person or organization
 *obtaining a copy of the software and accompanying documentation covered by
 *this license (the "Software") to use, reproduce, display, distribute,
 *execute, and transmit the Software, and to prepare derivative works of the
 *Software, and to permit third-parties to whom the Software is furnished to
 *do so, all subject to the following:
 *
 *The copyright notices in the Software and this entire statement, including
 *the above license grant, this restriction and the following disclaimer,
 *must be included in all copies of the Software, in whole or in part, and
 *all derivative works of the Software, unless such copies or derivative
 *works are solely in the form of machine-executable object code generated by
 *a source language processor.
 *
 *THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 *SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 *FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 *ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 *DEALINGS IN THE SOFTWARE.
 
 */

#ifndef KERNELS_GPU_ADD_HPP
#define KERNELS_GPU_ADD_HPP

#include "vli/detail/gpu/kernels/kernel_macros.h"

namespace vli{
    namespace detail{

    /* this version 60 more ptx lines, so boost pp  
     *  
     * asm( "add.cc.u32   %0 , %0 , %1 ; \n\t" : "+r"(x[0]):"r"(y[0])); 
     * #pragma unroll
     * for(int i=1; i < 11; ++i)
     *     asm( "addc.cc.u32  %0 , %0 , %1 ; \n\t" : "+r"(x[i]):"r"(y[i])); 
     *
     * I have to break up into 2 parts because I can not have more than 30 input/output          
     * load/write operation are done by the compiler (!= ASM x80-86) 
     */

    #define addn128_n128_gpu(w, n, unused) \
        asm( \
             BOOST_PP_IF(n,"addc.cc.u32 %0, %0, %4; \n\t","add.cc.u32  %0, %0, %4 ; \n\t") /* n=0 no CB,  n!=0, second pass needs CB */ \
            "addc.cc.u32 %1, %1, %5 ; \n\t" /* x[1] += y[1] + CB                                                                     */ \
            "addc.cc.u32 %2, %2, %6 ; \n\t" /* x[2] += y[2] + CB                                                                     */ \
            "addc.cc.u32 %3, %3, %7 ; \n\t" /* x[3] += y[3] + CB                                                                     */ \
            :"+r"(x[I(0,n)]),"+r"(x[I(1,n)]),"+r"(x[I(2,n)]),"+r"(x[I(3,n)])                                                            \
            :"r"(y[I(0,n)]),"r"(y[I(1,n)]),"r"(y[I(2,n)]),"r"(y[I(3,n)])                                                                \
           ); \

    #define FUNCTION_add_nbits_nbits(z, n, unused) \
       inline void NAME_ADD_NBITS_PLUS_NBITS(BOOST_PP_MUL(2,BOOST_PP_ADD(n,1)))(unsigned int* x, unsigned int const* y){                \
           BOOST_PP_REPEAT(BOOST_PP_ADD(n,2), addn128_n128_gpu, ~)                                                        \
       }                                                                                                                                \

    BOOST_PP_REPEAT(3, FUNCTION_add_nbits_nbits, ~) /* expend until 512 */
    #undef FUNCTION_add_nbits_nbits 
    #undef add_m128_n128_gpu

    }
}

#endif
