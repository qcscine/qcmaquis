/*
 * Copyright Institute for Theoretical Physics, ETH Zurich 2015.
 * Distributed under the Boost Software License, Version 1.0.
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef AMBIENT_CONTAINER_NUMERIC_BINDINGS_MKL
#define AMBIENT_CONTAINER_NUMERIC_BINDINGS_MKL

#define MKL_INT int
#define MKL_Complex16 std::complex<double>

extern "C" {

    void dgemm(const char *transa, const char *transb, const MKL_INT *m, const MKL_INT *n, const MKL_INT *k,
               const double *alpha, const double *a, const MKL_INT *lda, const double *b, const MKL_INT *ldb,
               const double *beta, double *c, const MKL_INT *ldc);

    void zgemm(const char *transa, const char *transb, const MKL_INT *m, const MKL_INT *n, const MKL_INT *k,
               const MKL_Complex16 *alpha, const MKL_Complex16 *a, const MKL_INT *lda,
               const MKL_Complex16 *b, const MKL_INT *ldb, const MKL_Complex16 *beta,
               MKL_Complex16 *c, const MKL_INT *ldc);

    void dgemv(const char *trans, const MKL_INT *m, const MKL_INT *n, const double *alpha,
               const double *a, const MKL_INT *lda, const double *x, const MKL_INT *incx,
               const double *beta, double *y, const MKL_INT *incy);

    void zgemv(const char *trans, const MKL_INT *m, const MKL_INT *n, const MKL_Complex16 *alpha,
               const MKL_Complex16 *a, const MKL_INT *lda, const MKL_Complex16 *x, const MKL_INT *incx,
               const MKL_Complex16 *beta, MKL_Complex16 *y, const MKL_INT *incy);

    void daxpy(const MKL_INT *n, const double *alpha, const double *x, const MKL_INT *incx, double *y, const MKL_INT *incy);

    void zaxpy(const MKL_INT *n, const MKL_Complex16 *alpha, const MKL_Complex16 *x, const MKL_INT *incx, MKL_Complex16 *y, const MKL_INT *incy);

    void dgesvd(const char* jobu, const char* jobvt, const MKL_INT* m, 
                const MKL_INT* n, double* a, const MKL_INT* lda, double* s,
                double* u, const MKL_INT* ldu, double* vt, const MKL_INT* ldvt,
                double* work, const MKL_INT* lwork, MKL_INT* info);

    void zgesvd(const char* jobu, const char* jobvt, const MKL_INT* m, 
                const MKL_INT* n, MKL_Complex16* a, const MKL_INT* lda, double* s,
                MKL_Complex16* u, const MKL_INT* ldu, MKL_Complex16* vt,
                const MKL_INT* ldvt, MKL_Complex16* work, const MKL_INT* lwork,
                double* rwork, MKL_INT* info);

    void dsyev(const char* jobz, const char* uplo, const MKL_INT* n, double* a, 
               const MKL_INT* lda, double* w, double* work, const MKL_INT* lwork,
               MKL_INT* info);

    void zheev(const char* jobz, const char* uplo, const MKL_INT* n, 
               MKL_Complex16* a, const MKL_INT* lda, double* w,
               MKL_Complex16* work, const MKL_INT* lwork, double* rwork,
               MKL_INT* info);

    void zgeev(const char* jobvl, const char* jobvr, const MKL_INT* n, 
               MKL_Complex16* a, const MKL_INT* lda, MKL_Complex16* w,
               MKL_Complex16* vl, const MKL_INT* ldvl, MKL_Complex16* vr,
               const MKL_INT* ldvr, MKL_Complex16* work, const MKL_INT* lwork,
               double* rwork, MKL_INT* info);

    void dgetrf(const MKL_INT* m, const MKL_INT* n, double* a, const MKL_INT* lda, 
                MKL_INT* ipiv, MKL_INT* info);

    void zgetrf(const MKL_INT* m, const MKL_INT* n, MKL_Complex16* a, 
                const MKL_INT* lda, MKL_INT* ipiv, MKL_INT* info);

    void dgetri(const MKL_INT* n, double* a, const MKL_INT* lda, 
                const MKL_INT* ipiv, double* work, const MKL_INT* lwork,
                MKL_INT* info);

    void zgetri(const MKL_INT* n, MKL_Complex16* a, const MKL_INT* lda, 
                const MKL_INT* ipiv, MKL_Complex16* work, const MKL_INT* lwork,
                MKL_INT* info);

}

#undef MKL_INT
#undef MKL_Complex16

namespace ambient { namespace numeric { namespace mkl {

    template<class T, class D>
    struct helper_cast;

    template<>
    struct helper_cast<std::complex<double>, double>{
        typedef std::complex<double> T;
        typedef double D;
        static T cast(D a){ return static_cast<T>(a); }
    };

    template<>
    struct helper_cast<double, std::complex<double> >{
        typedef double T;
        typedef std::complex<double> D;
        static T cast(D a){ return a.real(); }
    };

    template<>
    struct helper_cast<double, double>{
        typedef double T;
        typedef double D;
        static T cast(T a){ return a; }
    };

    template<>
    struct helper_cast<std::complex<double>, std::complex<double> >{
        typedef std::complex<double> T;
        typedef std::complex<double> D;
        static T cast(T a){ return a; }
    };

    template <class T>
    inline int OptimalSize(T a){ return (int)a; }

    template <class T>
    inline int OptimalSize(std::complex<T> a){ return (int)a.real(); }

    template<class T>
    struct helper_complex;

    template<>
    struct helper_complex<double>{
        typedef double T;
        static inline T conj(T x){ return x; }
        static inline T real(T x){ return x; }
    };
   
    template<>
    struct helper_complex<std::complex<double> >{
        typedef std::complex<double> T;
        static inline T conj(T x){ return std::conj(x); }
        static inline T real(T x){ return std::real(x); }
    };

    template<class T>
    struct blas;

    template<>
    struct blas<double> {
       typedef double T;
       static void gemm(const char* transa, const char* transb, const int* m, const int* n, const int* k, const T* alfa, const T* ad, const int* lda, const T* bd, const int* ldb, const T* beta, T* cd, const int* ldc){
          dgemm(transa, transb, m, n, k, alfa, ad, lda, bd, ldb, beta, cd, ldc);
       } 
    
       static void gemv(const char* transa, const int* m, const int* n, const T* alfa, const T* ad, const int* lda, const T* bd, const int* ldb, const T* beta, T* cd, const int* ldc){
          dgemv(transa, m, n, alfa, ad, lda, bd, ldb, beta, cd, ldc);
       }

       static void axpy(const int* n, const double* alfa, const T* ad, const int* inca, T* bd, const int* incb){
          daxpy(n, alfa, ad, inca, bd, incb);
       }

    };

    template<>
    struct blas<std::complex<double> > {
       typedef std::complex<double> T;
       static void gemm(const char* transa, const char* transb, const int* m, const int* n, const int* k, const T* alfa, const T* ad, const int* lda, const T* bd, const int* ldb, const T* beta, T* cd, const int* ldc){
          zgemm(transa, transb, m, n, k, alfa, ad, lda, bd, ldb, beta, cd, ldc);
       }

       static void gemv(const char* transa, const int* m, const int* n, const T* alfa, const T* ad, const int* lda, const T* bd, const int* ldb, const T* beta, T* cd, const int* ldc){
          zgemv(transa, m, n, alfa, ad, lda, bd, ldb, beta, cd, ldc);
       }

       static void axpy(const int* n, const T* alfa, const T* ad, const int* inca, T* bd, const int* incb){ // exp algorithm only
          zaxpy(n, alfa, ad, inca, bd, incb); 
       }

       static void axpy(const int* n, const typename T::value_type* alfa, const T* ad, const int* inca, T* bd, const int* incb){ // after SVD complex
          T beta(*alfa);
          zaxpy(n, &beta, ad, inca, bd, incb);
       }
    };

    template<class T>
    struct lapack;

    template<>
    struct lapack<double> {
       typedef double T;
       static void gesvd(const char* jobu, const char* jobvt, const int* m, const int* n, T* ad, const int* lda, T* sd, T* ud, const int* ldu, T* vtd, const int* ldvt, T* wkopt, int* lwork, int* info){
           T* work;
           dgesvd(jobu, jobvt, m, n, ad, lda, sd, ud, ldu, vtd, ldvt, wkopt, lwork, info);
           *lwork = OptimalSize(*wkopt);
           work = (T*)std::malloc( (*lwork)*sizeof(T) );
           dgesvd(jobu, jobvt, m, n, ad, lda, sd, ud, ldu, vtd, ldvt, work, lwork, info);
           assert( *info == 0 ); // otherwise SVD hasn't converged
           std::free(work);
       } 

       static void heev(const char* jobz, const char* uplo, const int* n, T* a, const int* lda, T* w, T* wkopt, int* lwork, int* info ){
           T* work;
           dsyev(jobz, uplo, n, a, lda, w, wkopt, lwork, info);
           assert( *info == 0 );
           *lwork = OptimalSize(*wkopt);
           work = (T*)std::malloc( (*lwork)*sizeof(T) );
           dsyev(jobz, uplo, n, a, lda, w, work, lwork, info);
           assert( *info == 0 );
           std::free(work);
       }

       static void getrf(const int* m, const int*n, T* a, const int* lda, int* ipiv, int* info){
           dgetrf(m, n, a, lda, ipiv, info);
           assert( *info == 0 );
       }

       static void getri(const int*n, T* a, const int* lda, int* ipiv, int* info){
           T* work;
           T wkopt;
           int lwork = -1;
           dgetri( n, a, lda, ipiv, &wkopt, &lwork, info);
           assert( *info == 0 );
           lwork = OptimalSize(wkopt);
           work = (T*)std::malloc(lwork*sizeof(T));
           dgetri( n, a, lda, ipiv, work, &lwork, info);
           assert( *info == 0 );
           std::free(work);
       }
    };

    template<>
    struct lapack<std::complex<double> > {
       typedef std::complex<double> T;
       static void gesvd(const char* jobu, const char* jobvt, const int* m, const int* n, T* ad, const int* lda, typename T::value_type* sd, T* ud, const int* ldu, T* vtd, const int* ldvt, T* wkopt, int* lwork, int* info){
           typename T::value_type* rwork = new typename T::value_type[std::max(1,5*std::min((*n),(*m)))]; // as of MKL doc
           T* work;
           zgesvd(jobu, jobvt, m, n, ad, lda, sd, ud, ldu, vtd, ldvt, wkopt, lwork, rwork, info); // query the optimal workspace
           assert( *info == 0 );
           *lwork = OptimalSize(*wkopt);
           work = (T*)std::malloc( (*lwork)*sizeof(T) );
           zgesvd(jobu, jobvt, m, n, ad, lda, sd, ud, ldu, vtd, ldvt, work, lwork, rwork, info);
           assert( *info == 0 ); // otherwise SVD hasn't converged
           std::free(work);
           delete [] rwork;
       } 

       static void heev(const char* jobz, const char* uplo, const int* n, T* a, const int* lda, typename T::value_type* w, T* wkopt, int* lwork, int* info ){
           typename T::value_type* rwork = new typename T::value_type[std::max(1,3*(*n)-2)]; // as of MKL doc
           T* work;
           zheev(jobz, uplo, n, a, lda, w, wkopt, lwork, rwork, info);
           assert( *info == 0 );
           *lwork = OptimalSize(*wkopt);
           work = (T*)std::malloc( (*lwork)*sizeof(T) );
           zheev(jobz, uplo, n, a, lda, w, work, lwork, rwork, info);
           assert( *info == 0 );
           std::free(work);
           delete [] rwork;
       }
  
       static void geev(const char* jobvl, const char* jobvr, const int* n, T* a, const int* lda, T* s, T* ldv, const int* ldlv, T* rvd, const int* ldrv, T* wkopt, int* lwork, int* info){
           typename T::value_type* rwork = new typename T::value_type[std::max(1,2*(*n))]; // as of MKL doc
           T* work;
           zgeev(jobvl, jobvr, n, a, lda, s, ldv, ldlv, rvd, ldrv, wkopt, lwork, rwork, info);
           assert( *info == 0 );
           *lwork = OptimalSize(*wkopt);
           work = (T*)std::malloc( (*lwork)*sizeof(T) );
           zgeev(jobvl, jobvr, n, a, lda, s, ldv, ldlv, rvd, ldrv, work, lwork, rwork, info);
           assert( *info == 0 );
           std::free(work);
           delete [] rwork;
       } 

       static void getrf(const int* m, const int*n, T* a, const int* lda, int* ipiv, int* info){
           zgetrf(m, n, a, lda, ipiv, info);
       }

       static void getri(const int*n, T* a, const int* lda, int* ipiv, int* info){
           T* work;
           T wkopt;
           int lwork = -1;
           zgetri( n, a, lda, ipiv, &wkopt, &lwork, info);
           assert( *info == 0 );
           lwork = OptimalSize(wkopt);
           work = (T*)std::malloc(lwork*sizeof(T));
           zgetri( n, a, lda, ipiv, work, &lwork, info);
           assert( *info == 0 );
           std::free(work);
       }
    };

} } }

#endif
