/*****************************************************************************
 *
 * ALPS MPS DMRG Project
 *
 * Copyright (C) 2016 Laboratory of Physical Chemistry, ETH Zurich
 *               2016 by Stefan Knecht <stknecht@ethz.ch>
 *               2016 by Sebastian Keller <sebkelle@phys.ethz.ch>
 *               2019 by Leon Freitag <lefreita@ethz.ch>
 *
 *
 * This software is part of the ALPS Applications, published under the ALPS
 * Application License; you can use, redistribute it and/or modify it under
 * the terms of the license, either version 1 or (at your option) any later
 * version.
 *
 * You should have received a copy of the ALPS Application License along with

 * the ALPS Applications; see the file LICENSE.txt. If not, the license is also
 * available from http://alps.comp-phys.org/.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *****************************************************************************/

#include <iostream>
#include <algorithm>
#include <string>
#include <boost/lexical_cast.hpp>

#include "dmrg/sim/matrix_types.h"
#include "dmrg/mp_tensors/mps_rotate.h"
#include "dmrg/models/model.h"
#include "dmrg/models/lattice.h"

#include "dmrg/utils/DmrgOptions.h"
#include "dmrg/utils/DmrgParameters.h"

#include "dmrg/models/generate_mpo.hpp"
#include "dmrg/models/chem/transform_symmetry.hpp"
#include "dmrg/models/chem/2u1/chem_helper.h"

// #include "../tools/ci_encode.hpp"
// #include "utils.hpp"

#if defined(USE_TWOU1)
typedef TwoU1 grp;
#elif defined(USE_TWOU1PG)
typedef TwoU1PG grp;
#elif defined(USE_SU2U1)
typedef SU2U1 grp;
#elif defined(USE_SU2U1PG)
typedef SU2U1PG grp;
// #elif defined(USE_NONE)
// typedef TrivialGroup grp;
// #elif defined(USE_U1)
// typedef U1 grp;
#endif

// function to read a scaling factor from an input file
template<class Matrix, class SymmGroup>
typename Matrix::value_type get_scaling(std::string file)
{
    std::ifstream scaling_file;
    scaling_file.open(file.c_str());
    double scale_coeff;

    scaling_file >> scale_coeff;
    typename Matrix::value_type factor = boost::lexical_cast<double>(scale_coeff);
    scaling_file.close();
    return factor;
}

// Assemble a t matrix from fcidump files generated by MOLCAS
template <class Matrix, class SymmGroup>
std::pair<Matrix, typename Matrix::value_type> get_t_from_files(std::size_t L, std::string scale_fac, std::string fcidump)
{
    typedef typename Matrix::value_type vt;
    Matrix ret(L,L);
    vt ret_inactive = get_scaling<Matrix, SymmGroup>(scale_fac + ".0");

    DmrgParameters parms_temp;
    parms_temp.set("L", L);
    parms_temp.set("integral_file", fcidump + ".1"); // needed to construct the lattice below. Make sure this file exists...
    Lattice lat(parms_temp); // this is needed for parse_integrals, although parse_integrals reads only L... such an overkill

    for (int i = 0; i < L; i++)
    {
        // get diagonal elements
        ret(i,i) = get_scaling<Matrix,SymmGroup>(scale_fac + "." + std::to_string(i+1));

        // get off-diagonal elements
        alps::numeric::matrix<Lattice::pos_t> index_temp;
        std::vector<vt> values_temp;
        parms_temp.set("integral_file", fcidump + "." + std::to_string(i+1));

        // parse MOLCAS FCIDUMP files
        std::tie(index_temp, values_temp) = chem::detail::parse_integrals<vt, SymmGroup>(parms_temp, lat, false);

        // copy the parsed integrals at their according positions in the ret matrix
        for (std::size_t m=0; m < values_temp.size(); m++)
        {
            int i = index_temp(m, 0), j = index_temp(m, 1), k = index_temp(m, 2), l = index_temp(m, 3);
            assert( k==-1 && l==-1);

            // the matrix elements in MOLCAS are already divided by the diagonal element
            // so we need to scale them back
            ret(i,j) = values_temp[m]*ret(j,j);
        }
    }

    return std::make_pair(ret, ret_inactive);
}

int main(int argc, char ** argv)
{
    try {
        if (argc != 2) {
            std::cout << "Usage: " << argv[0] << "mps.h5" << std::endl;
            return 1;
        }

        typedef Lattice::pos_t pos_t;

        //std::string rfile(parms.get<std::string>("resultfile"));

        MPS<matrix, grp> mps;
        load(argv[1], mps);

        // try to obtain orbital order for the MPS
        storage::archive ar(std::string(argv[1]) + "/props.h5");
        std::string orbital_order;
        try {
            ar["orbital_order"] >> orbital_order;
        }
        catch (...)
        {
            orbital_order = "";
        };

        mps.canonize(0);

        std::size_t L = mps.length();
        //maquis::cout << " Input MPS: " << std::endl;
        //debug::mps_print_ci(mps, "dets.txt");

        //maquis::cout << "norm of MPS: " << norm(mps) << std::endl;
        //debug::mps_print(mps, "Original MPS at site ");

        std::string scale_fac_file  = "tjj.tramps.orb";
        std::string fcidump_file    = "FCIDUMP.tramps.orb";

        matrix t;
        matrix::value_type scale_inactive;

        std::tie(t, scale_inactive) = get_t_from_files<matrix,grp>(L, scale_fac_file, fcidump_file);

        mps_rotate::rotate_mps(mps, t, scale_inactive);

        matrix::value_type final_norm = norm(mps);
        //maquis::cout << "norm of final MPS: " << norm(mps) << std::endl;

        // NOTE: this normalizes the final MPS and may invert signs
        //mps = compression::l2r_compress(mps, 10000, 1e-7);
        //mps[0].multiply_by_scalar(sqrt(final_norm));

        maquis::cout << " FINAL DATA" << std::endl << " ----------" << std::endl;
        //debug::mps_print(mps, " Rotated MPS at site ");
        //debug::mps_print_ci(mps, "dets.txt");

        maquis::cout << "norm of final MPS: " << norm(mps) << std::endl;

        save(argv[1], mps);

    } catch (std::exception& e) {
        std::cerr << "Error:" << std::endl << e.what() << std::endl;
        return 1;
    }
}
